import { TypedJSON, jsonMember, jsonObject } from 'typedjson';
import humanizeDuration from 'humanize-duration';
import { decodeBase16, encodeBase16 } from './Conversions';
import { RuntimeArgs } from './RuntimeArgs';

/**
 * Deserializes a `Uint8Array` into a hexadecimal string
 * @param bytes A `Uint8Array` to be deserialized
 * @returns A base-16 encoded string of the provided byte array
 */
export const byteArrayJsonSerializer: (bytes: Uint8Array) => string = (
  bytes: Uint8Array
) => {
  return encodeBase16(bytes);
};

/**
 * Deserializes a `Uint8Array` into a hexadecimal string
 * @param bytes A `Uint8Array` to be deserialized
 * @returns A base-16 encoded string of the provided byte array
 */
export const undefinedSafeByteArrayJsonSerializer: (
  bytes: Uint8Array | undefined
) => string | undefined = (bytes: Uint8Array | undefined) => {
  if (!bytes) {
    return undefined;
  }
  return encodeBase16(bytes);
};

//Shouldn't the above and below function names be swapped?

/**
 * Serializes a hexadecimal string to a `Uint8Array`
 * @param bytes A hexadecimal string to be serialized
 * @returns A base-16 encoded string of the provided byte array
 */
export const byteArrayJsonDeserializer: (str: string) => Uint8Array = (
  str: string
) => {
  return decodeBase16(str);
};

/**
 * Serializes a hexadecimal string to a `Uint8Array`
 * @param bytes A hexadecimal string to be serialized
 * @returns A base-16 encoded string of the provided byte array
 */
export const undefinedSafeByteArrayJsonDeserializer: (
  str: string | undefined
) => Uint8Array | undefined = (str: string | undefined) => {
  if (!str) {
    return undefined;
  }
  return decodeBase16(str);
};

/**
 * A struct containing a signature and the public key of the signer.
 */
@jsonObject
export class Approval {
  @jsonMember({ constructor: String })
  public signer: string;
  @jsonMember({ constructor: String })
  public signature: string;
}

const shortEnglishHumanizer = humanizeDuration.humanizer({
  spacer: '',
  serialComma: false,
  conjunction: ' ',
  delimiter: ' ',
  language: 'shortEn',
  languages: {
    // https://docs.rs/humantime/2.0.1/humantime/fn.parse_duration.html
    shortEn: {
      d: () => 'day',
      h: () => 'h',
      m: () => 'm',
      s: () => 's',
      ms: () => 'ms'
    }
  }
});

/**
 * Returns a humanizer duration
 * @param ttl in milliseconds
 * @returns A human-readable time in days, hours, minutes, seconds, then milliseconds
 */
export const humanizerTTL = (ttl: number) => {
  return shortEnglishHumanizer(ttl);
};

/**
 * Returns duration in milliseconds
 * @param ttl Human-readable string generated by [humanizerTTL](#L91)
 * @returns The time-to-live in milliseconds
 */
export const dehumanizerTTL = (ttl: string): number => {
  const dehumanizeUnit = (s: string): number => {
    if (s.includes('ms')) {
      return Number(s.replace('ms', ''));
    }
    if (s.includes('s') && !s.includes('m')) {
      return Number(s.replace('s', '')) * 1000;
    }
    if (s.includes('m') && !s.includes('s')) {
      return Number(s.replace('m', '')) * 60 * 1000;
    }
    if (s.includes('h')) {
      return Number(s.replace('h', '')) * 60 * 60 * 1000;
    }
    if (s.includes('day')) {
      return Number(s.replace('day', '')) * 24 * 60 * 60 * 1000;
    }
    throw Error('Unsuported TTL unit');
  };

  return ttl
    .split(' ')
    .map(dehumanizeUnit)
    .reduce((acc, val) => (acc += val));
};

/**
 * Deserializes an array of runtime arguments to a `RuntimeArgs` object
 * @param arr An array of type `any` containing valid serialized runtime arguments. Can be generated from [serRA](#L338)
 * @returns `RuntimeArgs` object
 */
export const desRA = (arr: any) => {
  const raSerializer = new TypedJSON(RuntimeArgs);
  const value = {
    args: arr
  };
  return raSerializer.parse(value);
};

/**
 * Serializes a `RuntimeArgs` object to a byte array
 * @param ra `RuntimeArgs` object to be serialized
 * @returns A serialized byte array of runtime arguments, which can be deserialized by [desRA](#L326)
 */
export const serRA = (ra: RuntimeArgs) => {
  const raSerializer = new TypedJSON(RuntimeArgs);
  const json = raSerializer.toPlainJson(ra);
  return Object.values(json as any)[0];
};
